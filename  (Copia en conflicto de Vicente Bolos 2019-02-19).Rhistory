signal2[500:1000] = signal2[500:1000] + sin((500:1000) / 2)
wsd <- wsd(signal1 = signal1, signal2 = signal2, mc_nrand = 10, makefigure = FALSE)
library(wavScalogram)
wsd <- wsd(signal1 = signal1, signal2 = signal2, mc_nrand = 10, makefigure = FALSE)
wavPlot(Z = -log2(wsd$wsd), X = wsd$t, Y = wsd$scales, Ylog = TRUE, coi = wsd$coi, rdist = wsd$rdist,
sig95 = wsd$signif95, sig05 = wsd$signif05, Xname = "Time", Yname = "Scale", Zname = "-log2(WSD)")
library(wavScalogram)
nt <- 1500
time <- 1:nt
sd_noise <-  0.2 #% In BolÃ³s et al. 2017 Figure 1, sd_noise = 1.
signal1 <- rnorm(n = nt, mean = 0, sd = sd_noise) + sin(time / 10)
signal2 <- rnorm(n = nt, mean = 0, sd = sd_noise) + sin(time / 10)
signal2[500:1000] = signal2[500:1000] + sin((500:1000) / 2)
wsd <- wsd(signal1 = signal1, signal2 = signal2, mc_nrand = 10, makefigure = FALSE)
wavPlot(Z = -log2(wsd$wsd), X = wsd$t, Y = wsd$scales, Ylog = TRUE, coi = wsd$coi, rdist = wsd$rdist,
sig95 = wsd$signif95, sig05 = wsd$signif05, Xname = "Time", Yname = "Scale", Zname = "-log2(WSD)")
library(wavScalogram)
library(wavScalogram)
library(afmToolkit)
data("batchExperiment")
datos <- batchExperiment[[8]]$data
datos <- subset(datos, Segment == "retract")
t <- 0:(nrow(datos)-1)
nt <- nrow(datos)
dt <- 1
# Defining the scales (Torrence and Compo's way)
s0 <- 2 * dt
Dj <- 32
waverad <- 1 # Morlet wavelet radius
J <- log2((t[nt] - t[1] - 2) / (2 * s0 * dt))
scales <- s0 * 2 ^ ((0:(J * Dj)) / Dj)
#scalog <- scalogram(signal = datos$Force, border_effects = "INNER", makefigure = TRUE, wname = "HAAR")
wt <- cwt_wst(signal = datos$Force, wname = "HAAR",
scales = scales)
wtsum <- colSums(abs(t(wt[,1:50])))
scales
plot(((wtsum-min(wtsum))/max(wtsum))^2.5, type = "l",ylim = c(0,1),lwd = 1,lty = 3, col = "red")
plot(((wtsum-min(wtsum))/max(wtsum))^1, type = "l",ylim = c(0,1),lwd = 1,lty = 3, col = "red")
wtsum <- colSums(abs(t(wt[,1:90])))
plot(((wtsum-min(wtsum))/max(wtsum))^1, type = "l",ylim = c(0,1),lwd = 1,lty = 3, col = "red")
lines((datos$Force-min(datos$Force))/max(datos$Force), lty = 1,lwd = 2)
wtsum[wtsum>5e-9] <- 0
plot(((wtsum-min(wtsum))/max(wtsum))^1, type = "l",ylim = c(0,1),lwd = 1,lty = 3, col = "red")
wtsum <- colSums(abs(t(wt[,1:50])))
wtsum[wtsum>5e-9] <- 0
plot(((wtsum-min(wtsum))/max(wtsum))^1, type = "l",ylim = c(0,1),lwd = 1,lty = 3, col = "red")
lines((datos$Force-min(datos$Force))/max(datos$Force), lty = 1,lwd = 2)
plot(((wtsum-min(wtsum))/max(wtsum))^1, type = "l",ylim = c(0,1),lwd = 1,lty = 3, col = "red")
plot(((wtsum-min(wtsum))/max(wtsum))^1.5, type = "l",ylim = c(0,1),lwd = 1,lty = 3, col = "red")
lines((datos$Force-min(datos$Force))/max(datos$Force), lty = 1,lwd = 2)
datos <- batchExperiment[[10]]$data
datos <- subset(datos, Segment == "retract")
t <- 0:(nrow(datos)-1)
nt <- nrow(datos)
dt <- 1
# Defining the scales (Torrence and Compo's way)
s0 <- 2 * dt
Dj <- 32
waverad <- 1 # Morlet wavelet radius
J <- log2((t[nt] - t[1] - 2) / (2 * s0 * dt))
scales <- s0 * 2 ^ ((0:(J * Dj)) / Dj)
#scalog <- scalogram(signal = datos$Force, border_effects = "INNER", makefigure = TRUE, wname = "HAAR")
wt <- cwt_wst(signal = datos$Force, wname = "HAAR",
scales = scales)
wtsum <- colSums(abs(t(wt[,1:50])))
hst <- hist(wtsum, breaks = 200)
hst$counts
wtsum[wtsum>5e-9] <- 0
plot(((wtsum-min(wtsum))/max(wtsum))^1.5, type = "l",ylim = c(0,1),lwd = 1,lty = 3, col = "red")
lines((datos$Force-min(datos$Force))/max(datos$Force), lty = 1,lwd = 2)
datos <- batchExperiment[[4]]$data
datos <- subset(datos, Segment == "retract")
t <- 0:(nrow(datos)-1)
nt <- nrow(datos)
dt <- 1
# Defining the scales (Torrence and Compo's way)
s0 <- 2 * dt
Dj <- 32
waverad <- 1 # Morlet wavelet radius
J <- log2((t[nt] - t[1] - 2) / (2 * s0 * dt))
scales <- s0 * 2 ^ ((0:(J * Dj)) / Dj)
#scalog <- scalogram(signal = datos$Force, border_effects = "INNER", makefigure = TRUE, wname = "HAAR")
wt <- cwt_wst(signal = datos$Force, wname = "HAAR",
scales = scales)
wtsum <- colSums(abs(t(wt[,1:50])))
wtsum[wtsum>5e-9] <- 0
plot(((wtsum-min(wtsum))/max(wtsum))^1.5, type = "l",ylim = c(0,1),lwd = 1,lty = 3, col = "red")
lines((datos$Force-min(datos$Force))/max(datos$Force), lty = 1,lwd = 2)
plot(((wtsum-min(wtsum))/max(wtsum))^1.5, type = "l",ylim = c(0,1),lwd = 1,lty = 3, col = "red")
wtsum <- colSums(abs(t(wt[,20:80])))
wtsum[wtsum>5e-9] <- 0
plot(((wtsum-min(wtsum))/max(wtsum))^1.5, type = "l",ylim = c(0,1),lwd = 1,lty = 3, col = "red")
lines((datos$Force-min(datos$Force))/max(datos$Force), lty = 1,lwd = 2)
points(kk$maxtab)
wtsum <- colSums(abs(t(wt[,80:120])))
wtsum[wtsum>5e-9] <- 0
plot(((wtsum-min(wtsum))/max(wtsum))^1.5, type = "l",ylim = c(0,1),lwd = 1,lty = 3, col = "red")
lines((datos$Force-min(datos$Force))/max(datos$Force), lty = 1,lwd = 2)
plot(((wtsum-min(wtsum))/max(wtsum))^1.5, type = "l",ylim = c(0,1),lwd = 1,lty = 3, col = "red")
lines((datos$Force-min(datos$Force))/max(datos$Force), lty = 1,lwd = 1)
#scalog <- scalogram(signal = datos$Force, border_effects = "INNER", makefigure = TRUE, wname = "HAAR")
wt <- cwt_wst(signal = datos$Force, wname = "MORLET",
scales = scales)
wtsum <- colSums(abs(t(wt[,80:120])))
hst <- hist(wtsum, breaks = 200)
wtsum[wtsum>5e-9] <- 0
plot(((wtsum-min(wtsum))/max(wtsum))^1.5, type = "l",ylim = c(0,1),lwd = 1,lty = 3, col = "red")
lines((datos$Force-min(datos$Force))/max(datos$Force), lty = 1,lwd = 1)
wtsum <- colSums(abs(t(wt[,10:120])))
wtsum[wtsum>5e-9] <- 0
plot(((wtsum-min(wtsum))/max(wtsum))^1.5, type = "l",ylim = c(0,1),lwd = 1,lty = 3, col = "red")
lines((datos$Force-min(datos$Force))/max(datos$Force), lty = 1,lwd = 1)
wtsum <- colSums(abs(t(wt[,10:50])))
wtsum[wtsum>5e-9] <- 0
plot(((wtsum-min(wtsum))/max(wtsum))^1.5, type = "l",ylim = c(0,1),lwd = 1,lty = 3, col = "red")
lines((datos$Force-min(datos$Force))/max(datos$Force), lty = 1,lwd = 1)
wtsum <- colSums(abs(t(wt[,10:80])))
wtsum[wtsum>5e-9] <- 0
plot(((wtsum-min(wtsum))/max(wtsum))^1.5, type = "l",ylim = c(0,1),lwd = 1,lty = 3, col = "red")
lines((datos$Force-min(datos$Force))/max(datos$Force), lty = 1,lwd = 1)
plot(((wtsum-min(wtsum))/max(wtsum))^1, type = "l",ylim = c(0,1),lwd = 1,lty = 3, col = "red")
lines((datos$Force-min(datos$Force))/max(datos$Force), lty = 1,lwd = 1)
#scalog <- scalogram(signal = datos$Force, border_effects = "INNER", makefigure = TRUE, wname = "HAAR")
wt <- cwt_wst(signal = datos$Force, wname "HAAR2",
scales = scales)
#scalog <- scalogram(signal = datos$Force, border_effects = "INNER", makefigure = TRUE, wname = "HAAR")
wt <- cwt_wst(signal = datos$Force, wname = "MORLET",
scales = scales)
#scalog <- scalogram(signal = datos$Force, border_effects = "INNER", makefigure = TRUE, wname = "HAAR")
wt <- cwt_wst(signal = datos$Force, wname = "haar2",
scales = scales)
wtsum <- colSums(abs(t(wt[,10:80])))
wtsum[wtsum>5e-9] <- 0
plot(((wtsum-min(wtsum))/max(wtsum))^1.5, type = "l",ylim = c(0,1),lwd = 1,lty = 3, col = "red")
lines((datos$Force-min(datos$Force))/max(datos$Force), lty = 1,lwd = 1)
#scalog <- scalogram(signal = datos$Force, border_effects = "INNER", makefigure = TRUE, wname = "HAAR")
wt <- cwt_wst(signal = datos$Force, wname = "haar2",
scales = scales)
wtsum <- colSums(abs(t(wt[,10:120])))
wtsum[wtsum>5e-9] <- 0
plot(((wtsum-min(wtsum))/max(wtsum))^1.5, type = "l",ylim = c(0,1),lwd = 1,lty = 3, col = "red")
#scalog <- scalogram(signal = datos$Force, border_effects = "INNER", makefigure = TRUE, wname = "HAAR")
wt <- cwt_wst(signal = datos$Force, wname = "haar",
scales = scales)
lines(((wtsum-min(wtsum))/max(wtsum))^1.5,lwd = 1,lty = 2, col = "blue")
library(wavScalogram)
library(wavScalogram)
library(wavScalogram)
roxygen2::roxygenise()
library(wavScalogram)
library(wavScalogram)
library(wavScalogram)
library(wavScalogram)
library(wavScalogram)
roxygen2::roxygenise()
library(wavScalogram)
library(wavScalogram)
roxygen2::roxygenise()
library(wavScalogram)
roxygen2::roxygenise()
?windowed_scalogram
time <- 1:500
signal <- c(sin(pi * time / 8), sin(pi * time / 16))
wscalog <- windowed_scalogram(signal = signal, makefigure = TRUE)
library(wavScalogram)
?col2rgb
library(wavScalogram)
?rgb
library(wavScalogram)
?convolve
?fft
?mvfft
library(wavScalogram)
?axis
?plot
?image
?colorRampPalette
?detectCores
library(wavScalogram)
roxygen2::roxygenise()
library(wavScalogram)
library(wavScalogram)
roxygen2::roxygenise()
library(wavScalogram)
roxygen2::roxygenise()
?quantile
library(wavScalogram)
library(wavScalogram)
library(wavScalogram)
library(wavScalogram)
x <- 1:10
x
x[1]-NA
xpad <- c(rep(NA,3),x,rep(NA,3))
xpad
neigh <- function(x,i,k, type = c("left","right","centered")){
if(type == "left"){
if(i == 1){
Nx <- c()
}else if(i>k){
Nx <- x[(i-k):(i-1)]
}else{
Nx <- x[1:(i-1)]
}
}else if(type == "right"){
if(i<(length(x)-k)){
Nx <- x[(i+1):(i+k)]
}else{
Nx <- x[(i+1):length(x)]
}
}else{
Nx <- c(neigh(x,i,k,type = "left"),neigh(x,i,k,type = "right"))
}
return(Nx)
}
x
neigh(x,1,3)
neigh(x,1,3, type = "left")
s1(x,1,3)
s1 <- function(x,i,k){
s1value <- 0.5*(max(x[i]-neigh(x,i,k,type = "left")) + max(x[i]-neigh(x,i,k,type = "right")))
return(s1value)
}
s1(x,1,3)
neigh <- function(x,i,k, type = c("left","right","centered")){
if(type == "left"){
if(i == 1){
Nx <- NA
}else if(i>k){
Nx <- x[(i-k):(i-1)]
}else{
Nx <- x[1:(i-1)]
}
}else if(type == "right"){
if(i<(length(x)-k)){
Nx <- x[(i+1):(i+k)]
}else{
Nx <- x[(i+1):length(x)]
}
}else{
Nx <- c(neigh(x,i,k,type = "left"),neigh(x,i,k,type = "right"))
}
return(Nx)
}
s1 <- function(x,i,k){
s1value <- 0.5*(max(x[i]-neigh(x,i,k,type = "left")) + max(x[i]-neigh(x,i,k,type = "right")))
return(s1value)
}
s1(x,1,3)
s1 <- function(x,i,k){
s1value <- 0.5*(max(x[i]-neigh(x,i,k,type = "left"),na.rm = TRUE) + max(x[i]-neigh(x,i,k,type = "right")))
return(s1value)
}
s1(x,1,3)
library(wavScalogram)
library(afmToolkit)
data("batchExperiment")
datos <- batchExperiment[[8]]$data
datos <- subset(datos, Segment == "retract")
t <- 0:(nrow(datos)-1)
nt <- nrow(datos)
dt <- 1
# Defining the scales (Torrence and Compo's way)
s0 <- 2 * dt
Dj <- 32
waverad <- 1 # Morlet wavelet radius
J <- log2((t[nt] - t[1] - 2) / (2 * s0 * dt))
scales <- s0 * 2 ^ ((0:(J * Dj)) / Dj)
scales
# Defining the scales (Torrence and Compo's way)
s0 <- 2 * dt
Dj <- 2
waverad <- 1 # Morlet wavelet radius
J <- log2((t[nt] - t[1] - 2) / (2 * s0 * dt))
scales <- s0 * 2 ^ ((0:(J * Dj)) / Dj)
scales
#scalog <- scalogram(signal = datos$Force, border_effects = "INNER", makefigure = TRUE, wname = "HAAR")
wt <- cwt_wst(signal = datos$Force, wname = "HAAR",
scales = scales)
wtsum <- colSums(abs(t(wt[,1:5])))
plot(((wtsum-min(wtsum))/max(wtsum))^2.5, type = "l",ylim = c(0,1),lwd = 1,lty = 3, col = "red")
hst <- hist(wtsum, breaks = 200)
wtsum[wtsum>1e-9] <- 0
plot(((wtsum-min(wtsum))/max(wtsum))^2.5, type = "l",ylim = c(0,1),lwd = 1,lty = 3, col = "red")
lines((datos$Force-min(datos$Force))/max(datos$Force), lty = 1,lwd = 2)
Dj <- 1
waverad <- 1 # Morlet wavelet radius
J <- log2((t[nt] - t[1] - 2) / (2 * s0 * dt))
scales <- s0 * 2 ^ ((0:(J * Dj)) / Dj)
#scalog <- scalogram(signal = datos$Force, border_effects = "INNER", makefigure = TRUE, wname = "HAAR")
wt <- cwt_wst(signal = datos$Force, wname = "HAAR",
scales = scales)
wtsum <- colSums(abs(t(wt[,1:5])))
hst <- hist(wtsum, breaks = 200)
hst$counts
wtsum[wtsum>1e-9] <- 0
plot(((wtsum-min(wtsum))/max(wtsum))^2.5, type = "l",ylim = c(0,1),lwd = 1,lty = 3, col = "red")
lines((datos$Force-min(datos$Force))/max(datos$Force), lty = 1,lwd = 2)
scales
wtsum <- colSums(abs(t(wt[,1:3])))
wtsum[wtsum>1e-9] <- 0
plot(((wtsum-min(wtsum))/max(wtsum))^2.5, type = "l",ylim = c(0,1),lwd = 1,lty = 3, col = "red")
lines((datos$Force-min(datos$Force))/max(datos$Force), lty = 1,lwd = 2)
wtsum <- colSums(abs(t(wt[,1:4])))
hst <- hist(wtsum, breaks = 200)
hst$counts
wtsum[wtsum>1e-9] <- 0
plot(((wtsum-min(wtsum))/max(wtsum))^2.5, type = "l",ylim = c(0,1),lwd = 1,lty = 3, col = "red")
lines((datos$Force-min(datos$Force))/max(datos$Force), lty = 1,lwd = 2)
points(kk$maxtab)
points(kk$mintab, col = "blue")
# Defining the scales (Torrence and Compo's way)
s0 <- 2 * dt
Dj <- 4
waverad <- 1 # Morlet wavelet radius
J <- log2((t[nt] - t[1] - 2) / (2 * s0 * dt))
scales <- s0 * 2 ^ ((0:(J * Dj)) / Dj)
#scalog <- scalogram(signal = datos$Force, border_effects = "INNER", makefigure = TRUE, wname = "HAAR")
wt <- cwt_wst(signal = datos$Force, wname = "HAAR",
scales = scales)
wtsum <- colSums(abs(t(wt[,1:4])))
hst <- hist(wtsum, breaks = 200)
wtsum[wtsum>5e-10] <- 0
plot(((wtsum-min(wtsum))/max(wtsum))^2.5, type = "l",ylim = c(0,1),lwd = 1,lty = 3, col = "red")
scales
wtsum <- colSums(abs(t(wt[,1:9])))
hst <- hist(wtsum, breaks = 200)
hst$counts
wtsum[wtsum>5e-10] <- 0
plot(((wtsum-min(wtsum))/max(wtsum))^2.5, type = "l",ylim = c(0,1),lwd = 1,lty = 3, col = "red")
# Defining the scales (Torrence and Compo's way)
s0 <- 2 * dt
Dj <- 4
waverad <- 1 # Morlet wavelet radius
J <- log2((t[nt] - t[1] - 2) / (2 * s0 * dt))
scales <- s0 * 2 ^ ((0:(J * Dj)) / Dj)
#scalog <- scalogram(signal = datos$Force, border_effects = "INNER", makefigure = TRUE, wname = "HAAR")
wt <- cwt_wst(signal = datos$Force, wname = "HAAR",
scales = scales)
wtsum <- colSums(abs(t(wt[,1:(Dj*3)])))
hst <- hist(wtsum, breaks = 200)
hst$counts
wtsum[wtsum>5e-10] <- 0
plot(((wtsum-min(wtsum))/max(wtsum))^2.5, type = "l",ylim = c(0,1),lwd = 1,lty = 3, col = "red")
hst <- hist(wtsum, breaks = 200)
wtsum[wtsum>1e-10] <- 0
plot(((wtsum-min(wtsum))/max(wtsum))^2.5, type = "l",ylim = c(0,1),lwd = 1,lty = 3, col = "red")
wtsum <- colSums(abs(t(wt[,1:(Dj*3)])))
#scalog <- scalogram(signal = datos$Force, border_effects = "INNER", makefigure = TRUE, wname = "HAAR")
wt <- cwt_wst(signal = datos$Force, wname = "HAAR",
scales = scales)
wtsum <- colSums(abs(t(wt[,1:(Dj*3)])))
hst <- hist(wtsum, breaks = 200)
wtsum[wtsum>1e-9] <- 0
plot(((wtsum-min(wtsum))/max(wtsum))^2.5, type = "l",ylim = c(0,1),lwd = 1,lty = 3, col = "red")
lines((datos$Force-min(datos$Force))/max(datos$Force), lty = 1,lwd = 2)
plot(((wtsum-min(wtsum))/max(wtsum))^1, type = "l",ylim = c(0,1),lwd = 1,lty = 3, col = "red")
lines((datos$Force-min(datos$Force))/max(datos$Force), lty = 1,lwd = 2)
plot(((wtsum-min(wtsum))/max(wtsum))^5, type = "l",ylim = c(0,1),lwd = 1,lty = 3, col = "red")
lines((datos$Force-min(datos$Force))/max(datos$Force), lty = 1,lwd = 2)
wtsum[wtsum>5e-8] <- 0
#scalog <- scalogram(signal = datos$Force, border_effects = "INNER", makefigure = TRUE, wname = "HAAR")
wt <- cwt_wst(signal = datos$Force, wname = "HAAR",
scales = scales)
wtsum <- colSums(abs(t(wt[,1:(Dj*3)])))
hst <- hist(wtsum, breaks = 200)
hst$counts
wtsum[wtsum>5e-8] <- 0
plot(((wtsum-min(wtsum))/max(wtsum))^5, type = "l",ylim = c(0,1),lwd = 1,lty = 3, col = "red")
plot(((wtsum-min(wtsum))/max(wtsum))^1.5, type = "l",ylim = c(0,1),lwd = 1,lty = 3, col = "red")
hst <- hist(wtsum, breaks = 200)
wtsum[wtsum>5e-9] <- 0
plot(((wtsum-min(wtsum))/max(wtsum))^1.5, type = "l",ylim = c(0,1),lwd = 1,lty = 3, col = "red")
lines((datos$Force-min(datos$Force))/max(datos$Force), lty = 1,lwd = 2)
library(wavScalogram)
library(wavScalogram)
library(afmToolkit)
data("batchExperiment")
datos <- batchExperiment[[8]]$data
datos <- subset(datos, Segment == "retract")
t <- 0:(nrow(datos)-1)
nt <- nrow(datos)
dt <- 1
# Defining the scales (Torrence and Compo's way)
s0 <- 2 * dt
Dj <- 4
waverad <- 1 # Morlet wavelet radius
J <- log2((t[nt] - t[1] - 2) / (2 * s0 * dt))
scales <- s0 * 2 ^ ((0:(J * Dj)) / Dj)
#scalog <- scalogram(signal = datos$Force, border_effects = "INNER", makefigure = TRUE, wname = "HAAR")
wt <- cwt_wst(signal = datos$Force, wname = "HAAR",
scales = scales)
wtsum <- colSums(abs(t(wt[,1:(Dj*3)])))
hst <- hist(wtsum, breaks = 200)
hst$counts
wtsum[wtsum>5e-9] <- 0
plot(((wtsum-min(wtsum))/max(wtsum))^1.5, type = "l",ylim = c(0,1),lwd = 1,lty = 3, col = "red")
lines((datos$Force-min(datos$Force))/max(datos$Force), lty = 1,lwd = 2)
plot(((wtsum-min(wtsum))/max(wtsum))^1.5, type = "l",ylim = c(0,1),lwd = 1,lty = 3, col = "red")
signal <- ((wtsum-min(wtsum))/max(wtsum))^1.5
res <- AnomalyDetectionTs(signal, max_anoms=0.02, direction='both', plot=TRUE)
res <- AnomalyDetection::AnomalyDetectionTs(signal, max_anoms=0.02, direction='both', plot=TRUE)
signal <- data.frame(Y = signal)
res <- AnomalyDetection::AnomalyDetectionTs(signal, max_anoms=0.02, direction='both', plot=TRUE)
signal <- data.frame(T = datos$Time,Y = signal)
res <- AnomalyDetection::AnomalyDetectionTs(signal, max_anoms=0.02, direction='both', plot=TRUE)
library(AnomalyDetection)
?AnomalyDetectionTs
datos$Time
as.POSIXct(1.23)
as.POSIXct(1.23, origin = 1)
?as.POSIXct
as.POSIXct(1.23, origin = "2018-01-01")
as.POSIXct(1.235, origin = "2018-01-01")
as.POSIXlt(1.235, origin = "2018-01-01")
as.POSIXlt(3.235, origin = "2018-01-01")
as.POSIXlt(3000, origin = "2018-01-01")
as.POSIXlt(3001, origin = "2018-01-01")
datos$Time
datos$Time*100
datos$Time*1000
signal <- data.frame(T = as.POSIXlt(datos$Time*1000,origin = "2018-01-01"),Y = signal)
res <- AnomalyDetection::AnomalyDetection(signal, max_anoms=0.02, direction='both', plot=TRUE)
res <- AnomalyDetectionTs(signal, max_anoms=0.02, direction='both', plot=TRUE)
signal <- data.frame(T = as.POSIXlt(datos$Time*1000,origin = "2018-01-01"),Y = signal)
signal
View(signal)
signal <- ((wtsum-min(wtsum))/max(wtsum))^1.5
signal <- data.frame(T = as.POSIXlt(datos$Time*1000,origin = "2018-01-01"),Y = signal)
res <- AnomalyDetectionTs(signal, max_anoms=0.02, direction='both', plot=TRUE)
res <- AnomalyDetectionTs(signal, max_anoms=0.02, direction='both', plot=TRUE, period = 0.1*1000)
res <- AnomalyDetectionTs(signal, max_anoms=0.01, direction='both', plot=TRUE)
# R package which includes Quantitative Financial Modelling Frameworks.
#https://www.rdocumentation.org/packages/quantmod
#install.packages("quantmod")
require(quantmod)
# An R Package of time series tools and utilities; Rmetrics - Financial Time Series Objects
#https://www.rdocumentation.org/packages/timeSeries
#install.packages("timeSeries")
require(timeSeries)
# devtools: Tools to Make Developing R Packages Easier
#https://www.rdocumentation.org/packages/devtools
#install.packages("devtools")
require(devtools) # using devtools to download from github
# R package for time series analysis using the Wavelet Scalogram
# from https://github.com/rbensua/wavScalogram
#install_github("rbensua/wavScalogram")
require(wavScalogram)
# Identify the tickers of interest
tickers <- c("CGW","XLE")
# Download these tickers from Yahoo for the dates in the presentation
getSymbols(tickers,src="yahoo", from = "2007-06-01",to = "2018-01-26")
# Merge all the Price series into one dataframe
AllPrices <- do.call(merge, lapply(tickers, function(x) get(x)))
#Some of these series have (NA) missing values for dates when others
# do not have missiong vaulesin the series so we interpolate for these values
AllPrices$CGW.Close <- interpNA(AllPrices$CGW.Close)
AllPrices$XLE.Close <- interpNA(AllPrices$XLE.Close)
#Set up the correct data frame
rCGW <- as.data.frame((AllPrices$CGW.Close))
rXLE <- as.data.frame((AllPrices$XLE.Close))
#Retrieve specific dates
date1 <- index(AllPrices)
#save Prices in Matrix
rW <- cbind(1:(length(AllPrices$CGW.Close)), rCGW$CGW.Close[1: length(AllPrices$CGW.Close)])
rE <- cbind(1:(length(AllPrices$XLE.Close)), rXLE$XLE.Close[1: length(AllPrices$XLE.Close)])
wname <- "MORLET"
#delta_t: Numeric. Increment of time for the construction of windows central times.
delta_t <- 1
nt <- length(rW)/2 # number of time points
t <- 1:nt # time vector
# mc_nrand: Integer. Number of Montecarlo simulations to be performed
# in order to determine the 95% and 5% significance contours.
mc_nrand <- 10  # MonteCarlo repetitions (for significance contours)
#windowrad: Numeric. Time radius for the windows
windowrad <- 64 #floor(nt/60); # % time radius for windowed scalogram (width)
#rdist: Numeric. Log-scale radius for the windows measured in suboctaves.
rdist <- floor(nt/300); # % Scale radius for distance (height)
dt <- 1; s0 <- 2*dt; Dj <- 12
waverad <- 3 # Morlet wavelet radius
smax <- (nt-1-2*windowrad)/(2*waverad)
scales <- c(s0, smax, Dj)
wsd <- wsd(signal1 = rW[,2], signal2 = rE[,2], scaleparam = scales, delta_t = delta_t,
windowrad = windowrad, rdist = rdist, mc_nrand = mc_nrand, wname = wname,
parallel = TRUE, makefigure = FALSE, border_effects = "PER")
wavPlot(Z = -log2(wsd$wsd), X = wsd$t, Y = wsd$scales, Ylog = TRUE, coi = wsd$coi,
rdist = wsd$rdist, sig95 = wsd$signif95, sig05 = wsd$signif05, Xname = "WSD: Water and Energy Prices",
Yname ="Scales (days)", Zname = " ")
#Adding in the dates for each of these 2 year spans (250 x 2)
axis(3, at =  c(0,500, 1000, 1500, 2000, 2500),labels=c("2007", "2009", "2011", "2013","2015", "2017"))
#Add annual lines and lines to distinguish between investment horizons
n = length(rW[, 1])
abline(v = seq(250, n, 250), h = 1:16, col = "grey", lty = 1, lwd = 1)
wsd <- wsd(signal1 = rW[,2], signal2 = rE[,2], scaleparam = scales, delta_t = delta_t,
windowrad = windowrad, rdist = rdist, mc_nrand = mc_nrand, wname = wname, normalize = TRUE,
parallel = TRUE, makefigure = FALSE, border_effects = "PER")
wavPlot(Z = -log2(wsd$wsd), X = wsd$t, Y = wsd$scales, Ylog = TRUE, coi = wsd$coi,
rdist = wsd$rdist, sig95 = wsd$signif95, sig05 = wsd$signif05, Xname = "WSD: Water and Energy Prices",
Yname ="Scales (days)", Zname = " ")
#Adding in the dates for each of these 2 year spans (250 x 2)
axis(3, at =  c(0,500, 1000, 1500, 2000, 2500),labels=c("2007", "2009", "2011", "2013","2015", "2017"))
#Add annual lines and lines to distinguish between investment horizons
n = length(rW[, 1])
abline(v = seq(250, n, 250), h = 1:16, col = "grey", lty = 1, lwd = 1)
plot(XLE)
plot(rW)
plot(rE)
plot(rW)
plot(rE)
?wsd
install.packages(c("abind","colorRamps","fields"))
library(wavScalogram)
